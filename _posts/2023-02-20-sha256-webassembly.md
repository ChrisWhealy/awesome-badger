---
layout: post
title:  "Implementing the SHA256 Message Digest Algorithm in WebAssembly Text"
date:   2023-02-20 12:00:00 +0000
category: chriswhealy
author: Chris Whealy
excerpt: WebAssembly Text (WAT) is ideally suited for implementing CPU intensive algorithms such as calculating a file's SHA256 digest.  This blog describes not only how I got this algorithm working in WebAssembly Text, but takes a wider view at the areas where improvements could be made both in the host environment (JavaScript in this case) and in the overall developer experience of working with WAT.
---

## But Why?

Let's be honest: writing a program of any usefullness in WebAssembly Text is a labour-intensive task that can almost certainly be achieved much quicker by solving the problem in a higher-level langauge, then getting the compiler to generate a WebAssembly module for you.

That's all true; however, if you look inside WebAssembly modules generated by compilers, you will see that a very large amount of extra coding has been inserted that, strictly speaking, does not need to be there.
This is particularly true when compiling from Rust to WebAssembly, since `cargo` helpfully inserts lots of error handling and memory management code that only ***might*** be needed; and since memory and CPU resources are super cheap nowadays, it can be argued that little practical benefit can be obtained by spending the time trying to make the binary smaller and faster.

However, before we write this off as another Yak-shaving exercise, let's see what we can learn when we go through the process of implementing nothing more than the code needed to perform the task at hand &mdash; namely, to calculate the SHA256 digest of a particular message.

## SHA256: What Is It?

The SHA256 algorithm is one of the ***S***ecure ***H***ash ***A***lgorithm-2 family of cryptographic functions published by the United States [National Security Agency](https://en.wikipedia.org/wiki/National_Security_Agency) in 2001.

The purpose of these algorithms is to generate an output called a ***hash*** that, for all practical purposes, can be considered unique for the given input.
In this sense, a hash represents a message's unique digitial fingerprint.

In the same way that the probability of finding two human beings with identical fingerprints is unfeasibly low, so the probability of finding two input values that generate the same SHA256 hash value is also unfeasibly low.

In more technical terms, for any secure hash value of length `n` bits, the probability of a brute force attack finding the input value that generated it is one chance in <code>2<sup>n</sup></code>: that's 1 chance in 2<sup>256</sup> or 1.15792089237 * 10<sup>77</sup> &mdash; which is a number so astronomically large that it's not even worth starting.

## Development Challenges

Two challenges had to be overcome during development:

1. The SHA256 algorithm expects to handle data in network byte order, but WebAssembly only has numeric data types that automatically rearrange a value's byte order according to the CPU's endianness.
1. Unit testing WASM functions within a module is an entirely manual process.
   This presented an interesting challenge when writing unit tests for WASM functions that did not need to be exported (I.E. private functions)

## Table of Contents

- [SHA256: What Is It?](/chriswhealy/sha256/algorithm-description/)
- [SHA256 Algorithm Overview](/chriswhealy/sha256/algorithm-overview/)
- [WebAssembly Has No `raw` Data Type](/chriswhealy/sha256/endianness/)
- [WebAssembly Program Architecture](/chriswhealy/sha256/architecture/)
- [WebAssembly Implementation](/chriswhealy/sha256/implementation/)
- [Unit Testing WebAssembly Functions](/chriswhealy/sha256/testing/)
